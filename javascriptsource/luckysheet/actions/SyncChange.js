// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE

/*
```
+------------------------------------------------------------------------------------------+                +------------------------------+
|                                                                                          |                |                              |
|    mendix client                                                                         |                |                              |
|                                                                                          |                |                              |
|                                                                                          |                |                              |
|             +------------------------+                       +---------------------+     |                |                              |
|             |                        |                       |                     |     |                |                              |
|             |     render action      |  -------emit------->  |  synchange action   |     |                |                              |
|             |                        |                       |                     |     |                |                              |
|             +------------------------+                       |                     |     |                |                              |
|                                                              +---------------------+     |                |                              |
|                    |          ^                                                          |                |                              |
|                    |          |                                    /-                    |                |                              |
|               send             post                              /-                      |                |                              |
|                    |          |                                /-                        |                |        mendix server         |
|                    |          |                              send                        |                |                              |
|                    v          |                            /-                            |                |                              |
|             +------------------------------------+       /-                              |                |                              |
|             |                                    |     /-                                |                |                              |
|             |                                    |   <-                                  |                |                              |
|             |         iframe LuckySheet          |                                       |                |                              |
|             |                                    |                                       |                |                              |
|             |                                    |                                       |                |                              |
|             |                                    |                                       |                |                              |
|             +------------------------------------+                                       |                |                              |
|                                                                                          |                |                              |
|                                                                                          |                |                              |
|                                                                                          |                |                              |
+------------------------------------------------------------------------------------------+                +------------------------------+
```

*/
async function fetchPage(entity, nameAtts) {
	return await new Promise((resolve, reject) => {
		mx.data.get({
			//Entity_2
			xpath: '//' + entity,
			count: true, filter: {
				attributes: nameAtts,
				//sort: [['createdDate', 'asc']],
				//offset,
				//amount, 
				//references: { 'MyFirstModule.Part_ProduceLog': { attributes: ['Week', 'Sum'], sort: [['Week', 'asc']] } }
			}, callback: (objs, extra) => {
				resolve([objs, extra]);
			}
		});
	});

}

async function injectDeps(deps) {
	return await new Promise((resolve, reject) => {
		if (!Array.isArray(deps)) {
			deps = [deps];
		}
		window.dojoDynamicRequire(deps, function () { resolve(Array.from(arguments)) });
	});
}

// https://codesandbox.io/s/luckysheet-unit-test-o4r278?file=/src/index.js
function Store(config) {
	let entity,
		objs = new Map();
	//normal or denormal
	let isVertical = true,
		offset,
		start;
	//map
	const colMap = new Map(),
		guidArray = [];
	//demap
	const guidMap = new Map(),
		attMap = new Map();

	config.split(";").forEach((d) => {
		const e = d.split(":");
		switch (e[0]) {
			case "entity":
				if (isNaN(+e[1])) {
					isVertical = false;
					start = parseInt(e[1], 36) - 9;
				} else {
					start = +e[1];
				}
				offset = +e[2];
				entity = e[3]; //entity qualify name
				break;

			case "column":
				if (!isNaN(+e[1])) {
					isVertical = false;
				}
				const loc = isVertical ? parseInt(e[1], 36) - 9 : +e[1];
				if (!attMap.has(loc)) {
					attMap.set(e[2], loc);
					colMap.set(loc, e[2]); //abs rc->abs column name
				}
				break;
			default:
		}
	});

	function _store() { }

	_store.getConfig = function () {
		return {
			v: isVertical,
			s: start,
			o: offset,
			e: guidArray.length,
			cs: Array.from(colMap.keys())
		};
	};

	_store.add = function (obj) {
		if (!guidMap.has(obj.getGuid())) {
			guidMap.set(obj.getGuid(), guidArray.length);
			guidArray.push(obj.getGuid());
			objs.set(obj.getGuid(), obj);
		}
	};

	//right
	_store.getGuidAndName = function (r, c) {
		//normal
		let _r = isVertical ? r : c,
			_c = isVertical ? c : r;
		if ((_r - start) % offset > 0) return [];
		_r = (_r - start) / offset;
		if (_r > guidArray.length - 1) return [];
		//map
		return [guidArray[_r], colMap.get(_c)];
	};

	//left
	_store.getRange = function (guid, att) {
		if (!att) {
			return Array.from(attMap.values()).map((_c) => {
				return isVertical
					? [start + offset * guidMap.get(guid), _c]
					: [_c, start + offset * guidMap.get(guid)];
			});
		}
		if (guidMap.has(guid) && attMap.has(att)) {
			//denormal
			//demap
			let _r = guidMap.get(guid),
				_c = attMap.get(att);
			_r = start + offset * _r;
			if (!isVertical) {
				const t = _c;
				_c = _r;
				_r = t;
			}

			return [_r, _c];
		} else return [guidMap.get(guid), attMap.get(att)];
	};

	_store.getObj = function (guid) {
		return objs.get(guid);
	};

	_store.getEntity = function () {
		return entity;
	};
	_store.getColumns = function () {
		return Array.from(colMap.values());
	};

	_store.isValid = function (r, c) {
		let _r = isVertical ? r : c,
			_c = isVertical ? c : r;
		if ((_r - start) % offset > 0 || _r - start < 0) return false;

		return colMap.has(_c);
	};

	_store.forEach = function (cb) {
		const { v, s, o, e, cs } = _store.getConfig();

		for (let ir = 0; ir < e; ir++) {
			cs.forEach((ic) => {
				cb(
					v ? s + ir * o - 1 : ic - 1,
					v ? ic - 1 : s + ir * o - 1,
					_store.getObj(guidArray[ir])
				);
			});
		}
	};

	_store.remove = function (guid) {
		if (guidMap.has(guid)) {
			guidMap.delete(guid);

			guidArray.length = 0;
			guidMap.forEach((v, k) => {
				guidMap.set(k, guidArray.length);
				guidArray.push(k);
			});

			objs.delete(guid);
		}
	};

	return _store;
}

// END EXTRA CODE

/**
 * @param {string} containerId
 * @param {string} config - start,offset:entity name;

2,1:LuckySheet.Entity;a:Name
 * @returns {Promise.<void>}
 */
export async function SyncChange(containerId, config) {
	// BEGIN USER CODE
	const [on, all] = await injectDeps(["dojo/on", "dojo/promise/all"]);
	const s = Store(config), entity = s.getEntity(), columns = s.getColumns();
	const container = document.querySelector('#' + containerId);
	function sendCommand(msg) {
		msg.mx_luckysheet.widgetid = containerId;
		container.querySelector('iframe').contentWindow && container.querySelector('iframe').contentWindow.postMessage(msg, '*');
	}

	async function updateEntity() {
		const [objs, extra] = await fetchPage(entity, columns);

		const myData = [];
		objs.forEach((obj, i) => {
			s.add(obj);

			columns.forEach(col => {
				const [r, c] = s.getRange(obj.getGuid(), col);
				myData.push({
					r: r - 1,
					c: c - 1,
					v: {
						bg: null,
						bl: 0,
						it: 0,
						ff: 0,
						fs: 11,
						fc: "rgb(51, 51, 51)",
						ht: 1,
						vt: 1,
						v: obj.get(col).toNumber ? obj.get(col).toNumber() : obj.get(col),
						ct: { fa: "General", t: "n" },
						//m: "3"
					}
				});
			})
		});

		const cfg = s.getConfig();
		cfg.data = myData;

		sendCommand({
			mx_luckysheet: {
				id: 'updateRange', data: cfg,
				lang: mx.session.sessionData.locale.code.split('_')[0]
			}
		});
	}

	// sync change from excel to mendix
	on(container, 'cellUpdated', (e) => {
		const data = e.data;

		if (s.isValid(data.r + 1, data.c + 1)) {
			const [g, n] = s.getGuidAndName(data.r + 1, data.c + 1), obj = s.getObj(g);

			if (g) {
				if (data.newValue.v == undefined) {
					mx.data.remove({
						guid: g,
						callback: function () {
							console.log("Object removed");
							mx.data.update({
								entity: entity,
							});
						},
						error: function (e) {
							console.error("Could not remove object:", e);
						}
					});
				}
				else {
					obj.set(n, data.newValue.v);

					mx.data.commit({
						mxobj: obj,
						callback: function () {
							console.log("Object committed");
							mx.data.update({
								entity: entity,
							});
						},
						error: function (e) {
							console.error("Could not commit object:", e);
						}
					});
				}
			} else {
				mx.data.create({
					entity,
					callback: function (obj2) {
						s.add(obj2);
						const [g2, n2] = s.getGuidAndName(data.r + 1, data.c + 1);
						obj2.set(n2, data.newValue.v);

						mx.data.commit({
							mxobj: obj2,
							callback: function () {
								console.log("Object committed");
								mx.data.update({
									entity,
								});
							},
							error: function (e) {
								console.error("Could not commit object:", e);
							}
						});

						console.log("Object created on server");
					},
					error: function (e) {
						console.error("Could not commit object:", e);
					}
				});
			}
		}
	});

	on(container, 'rangePasteAfter', (e) => {
		const { range, originData, pasteData } = e.data;
		console.log('rangeMoveAfter', range, originData, pasteData);
	});


	on(container, 'rangeMoveAfter', (e) => {
		const { oldRange, newRange } = e.data;
		console.log('rangeMoveAfter', oldRange, newRange);
	});

	// sync change from mendix to excel
	on(container, 'load', (e) => {
		const data = e.data;

		//加载数据
		updateEntity();
		//监听实体事件
		var subscription1 = mx.data.subscribe({
			entity: entity,
			callback: function (entity) {
				console.log("Update on entity " + entity);
				updateEntity();
			}
		});
	});

	//range del
	on(container, 'updated', (e) => {
		const { operate } = e.data;

		const guids = [];
		if (operate.type == 'datachange') {
			if (operate.curdata.length == 0) {
				//have not init
				return;
			}
			s.forEach((r, c, obj) => {
				const cell = operate.curdata[r][c];
				if (!cell || cell.v == undefined) {
					guids.push(obj.getGuid());
				}
			});
		}

		// clean entity data area
		const cfg = s.getConfig();
		cfg.data = undefined;//indicate no refresh
		if (guids.length > 0) {
			//FIXME delay 100ms refresh sheet, luckysheet.refresh() call setTimeout internal and also trigger updated event
			sendCommand({
				mx_luckysheet: {
					id: 'updateRange', data: cfg,
					lang: mx.session.sessionData.locale.code.split('_')[0]
				}
			});
		} else {
			//exit dead loop
			return;
		}

		// update store
		guids.forEach(guid => {
			/*s.getRange(guid).forEach(rc=>{
				console.log('dddddd', rc)
			});*/
			s.remove(guid);
		});

		// remove entity and trigger update
		setTimeout(() => {

			all(guids.map(guid => new Promise((resolve, reject) => {
				mx.data.remove({
					guid,
					callback: function () {
						console.log("Object removed");
						resolve();
					},
					error: function (e) {
						console.error("Could not remove object:", e);
						reject();
					}
				});
			}))).then(() => {
				guids.length = 0;
				mx.data.update({
					entity: entity,
				});
			});

		}, 200);
	});
	// END USER CODE
}
